**1. Program to Display Current Date and Time in Java:**

   You can use the `java.time` package introduced in Java 8 to display the current date and time. Here's a program to do that:

   ```java
   import java.time.LocalDateTime;
   import java.time.format.DateTimeFormatter;

   public class CurrentDateTimeExample {
       public static void main(String[] args) {
           // Get the current date and time
           LocalDateTime currentDateTime = LocalDateTime.now();

           // Define a custom format
           DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");

           // Format and display the current date and time
           String formattedDateTime = currentDateTime.format(formatter);
           System.out.println("Current Date and Time: " + formattedDateTime);
       }
   }
   ```

**2. Write a Program to Convert a Date to a String in the Format "MM/dd/yyyy":**

   You can use the `java.time` package to convert a `LocalDate` to a string in a specific format. Here's an example:

   ```java
   import java.time.LocalDate;
   import java.time.format.DateTimeFormatter;

   public class DateToStringExample {
       public static void main(String[] args) {
           // Create a LocalDate
           LocalDate date = LocalDate.of(2023, 9, 15);

           // Define a custom format
           DateTimeFormatter formatter = DateTimeFormatter.ofPattern("MM/dd/yyyy");

           // Format the date as a string
           String formattedDate = date.format(formatter);
           System.out.println("Formatted Date: " + formattedDate);
       }
   }
   ```

**3. What Is the Difference Between Collections and Streams? Explain with an Example:**

   - **Collections:** Collections in Java are data structures used to store, retrieve, and manipulate groups of objects. They provide methods for adding, removing, and accessing elements. Collections are typically used to represent and work with finite sets of data.

   - **Streams:** Streams in Java are a sequence of elements that can be processed in a functional and declarative style. Streams are used to perform operations on data, such as filtering, mapping, and reducing, without modifying the original data source. Streams are often used for data processing tasks and can work with both finite and infinite data.

   Example:
   ```java
   // Using a collection (List) to filter and collect even numbers
   List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
   List<Integer> evenNumbers = new ArrayList<>();

   for (Integer num : numbers) {
       if (num % 2 == 0) {
           evenNumbers.add(num);
       }
   }
   System.out.println("Even Numbers (Using Collection): " + evenNumbers);

   // Using a stream to filter and collect even numbers
   List<Integer> evenNumbersStream = numbers.stream()
                                           .filter(num -> num % 2 == 0)
                                           .collect(Collectors.toList());
   System.out.println("Even Numbers (Using Stream): " + evenNumbersStream);
   ```

   In this example, both the collection and the stream are used to filter and collect even numbers from a list of integers. The stream approach is more concise and declarative.

**4. What Is Enums in Java? Explain with an Example:**

   Enums (enumerations) in Java are a special data type used to define a set of named constants. They are typically used to represent a finite set of related values. Enum constants are implicitly `public`, `static`, and `final`. Here's an example:

   ```java
   public enum DayOfWeek {
       SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY
   }

   public class EnumExample {
       public static void main(String[] args) {
           DayOfWeek today = DayOfWeek.WEDNESDAY;
           System.out.println("Today is " + today);
       }
   }
   ```

   In this example, we define an enum `DayOfWeek` with constants representing the days of the week. We then use an enum constant (`DayOfWeek.WEDNESDAY`) to represent the current day.

**5. What Are Built-in Annotations in Java?**

   Java provides several built-in annotations that have special meanings and can be used to provide metadata about classes, methods, fields, and more. Some common built-in annotations include:
   - `@Override`: Indicates that a method is intended to override a method in a superclass.
   - `@Deprecated`: Marks a method, class, or field as deprecated, indicating that it should no longer be used.
   - `@SuppressWarnings`: Suppresses specific warnings generated by the compiler.
   - `@FunctionalInterface`: Specifies that an interface is intended to be a functional interface, which can have only one abstract method.

   These annotations are used by the compiler and various tools to provide additional information or perform specific actions during code compilation and analysis.